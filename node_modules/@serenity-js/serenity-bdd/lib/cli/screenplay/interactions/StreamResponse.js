"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamResponse = void 0;
const core_1 = require("@serenity-js/core");
const io_1 = require("@serenity-js/core/lib/io");
const rest_1 = require("@serenity-js/rest");
const model_1 = require("../../model");
const abilities_1 = require("../abilities");
/**
 * @package
 */
class StreamResponse extends core_1.Interaction {
    static to(request) {
        return {
            to: (destination) => new StreamResponse(request, destination),
        };
    }
    constructor(request, destination) {
        super((0, io_1.d) `#actor saves response to ${request} in ${destination.value}`);
        this.request = request;
        this.destination = destination;
    }
    /**
     * @desc
     *  Makes the provided {@apilink @serenity-js/core/lib/screenplay/actor~Actor}
     *  perform this {@apilink @serenity-js/core/lib/screenplay~Interaction}.
     *
     * @param {UsesAbilities & CollectsArtifacts & AnswersQuestions} actor
     * @returns {Promise<void>}
     *
     * @see {@apilink @serenity-js/core/lib/screenplay/actor~Actor}
     * @see {@apilink @serenity-js/core/lib/screenplay/actor~UsesAbilities}
     * @see {@apilink @serenity-js/core/lib/screenplay/actor~CollectsArtifacts}
     * @see {@apilink @serenity-js/core/lib/screenplay/actor~AnswersQuestions}
     */
    performAs(actor) {
        return actor.answer(this.request)
            .then((config) => rest_1.CallAnApi.as(actor).request({
            ...config,
            responseType: 'stream',
        })
            .then(response => {
            if (response.status !== 200) {
                throw new core_1.ConfigurationError(`Received: "${response.status} ${response.statusText}" when trying to download ${config.url}`);
            }
            return response;
        })
            .then(response => new Promise((resolve, reject) => {
            actor.collect(model_1.Notification.fromJSON({ message: `Downloading ${config.url} to ${this.destination.value}` }));
            const totalBytes = Number.parseInt(response.headers['content-length'], 10), output = abilities_1.UseFileSystem.as(actor).createWriteStreamTo(this.destination);
            let totalDownloadedBytes = 0;
            response.data.pipe(output);
            response.data.on('data', chunk => {
                const downloadedBytes = chunk.length;
                totalDownloadedBytes += downloadedBytes;
                actor.collect(model_1.DownloadProgressReport.fromJSON({
                    downloadedBytes,
                    totalDownloadedBytes,
                    totalBytes,
                }));
            });
            response.data.on('end', () => {
                output.end();
                return resolve();
            });
            response.data.on('error', error => reject(error));
        })));
    }
}
exports.StreamResponse = StreamResponse;
//# sourceMappingURL=StreamResponse.js.map