"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneSequenceEventQueueProcessor = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const tiny_types_1 = require("tiny-types");
const EventQueueProcessor_1 = require("../EventQueueProcessor");
const transformations_1 = require("../transformations");
const SceneSequenceReportContext_1 = require("./SceneSequenceReportContext");
const transformations_2 = require("./transformations");
const scenarioParameterResult_1 = require("./transformations/scenarioParameterResult");
const scenarioParametersOf_1 = require("./transformations/scenarioParametersOf");
/**
 * @package
 */
class SceneSequenceEventQueueProcessor extends EventQueueProcessor_1.EventQueueProcessor {
    supports(queue) {
        return queue
            && queue.first() instanceof events_1.SceneSequenceDetected;
    }
    process(queue) {
        return queue.reduce((context, event) => 
        // eslint-disable-next-line @typescript-eslint/indent
        (0, tiny_types_1.match)(event)
            .when(events_1.SceneSequenceDetected, this.onSceneSequenceDetected(context))
            .when(events_1.SceneStarts, this.onSceneStarts(context))
            .when(events_1.SceneTemplateDetected, this.onSceneTemplateDetected(context))
            .when(events_1.SceneParametersDetected, this.onSceneParametersDetected(context))
            .when(events_1.FeatureNarrativeDetected, this.onFeatureNarrativeDetected(context))
            .when(events_1.SceneBackgroundDetected, this.onSceneBackgroundDetected(context))
            .when(events_1.SceneDescriptionDetected, this.onSceneDescriptionDetected(context))
            .when(events_1.BusinessRuleDetected, this.onBusinessRuleDetected(context))
            .when(events_1.TestRunnerDetected, this.onTestRunnerDetected(context))
            .when(events_1.SceneTagged, this.onSceneTagged(context))
            .when(events_1.ActivityStarts, this.onActivityStarts(context))
            .when(events_1.ActivityFinished, this.onActivityFinished(context))
            .when(events_1.ActivityRelatedArtifactGenerated, this.onActivityRelatedArtifactGenerated(context))
            .when(events_1.ActivityRelatedArtifactArchived, this.onActivityRelatedArtifactArchived(context))
            .when(events_1.SceneFinished, this.onSceneFinished(context))
            .else(() => context), new SceneSequenceReportContext_1.SceneSequenceReportContext() // eslint-disable-line @typescript-eslint/indent
        ).build();
    }
    onSceneSequenceDetected(context) {
        return (event) => context
            .with((0, transformations_1.reportIdIncluding)(event.details.category.value, event.details.name.value))
            .with((0, transformations_1.scenarioDetailsOf)(event.details));
    }
    onSceneStarts(context) {
        return (event) => context
            .with((0, transformations_1.activityStarted)(event.sceneId, event.details.name, event.timestamp))
            .with((0, transformations_1.executionStartedAt)(event.timestamp));
    }
    onSceneTemplateDetected(context) {
        return (event) => context
            .with((0, transformations_2.scenarioOutlineOf)(event.template));
    }
    onSceneParametersDetected(context) {
        return (event) => context
            .with((0, scenarioParametersOf_1.scenarioParametersOf)(event.details, event.parameters));
    }
    onActivityStarts(context) {
        return (event) => context
            .with((0, transformations_1.activityStarted)(event.activityId, event.details.name, event.timestamp));
    }
    onActivityFinished(context) {
        return (event) => context
            .with((0, transformations_1.activityFinished)(event.activityId, event.outcome, event.timestamp));
    }
    onSceneFinished(context) {
        return (event) => context
            .with((0, transformations_1.activityFinished)(event.sceneId, event.outcome, event.timestamp))
            .with((0, scenarioParameterResult_1.scenarioParameterResult)(event.details, event.outcome))
            .with((0, transformations_2.sceneSequenceOverallResult)(event.outcome))
            .with((0, transformations_1.executionFinishedAt)(event.timestamp));
    }
}
exports.SceneSequenceEventQueueProcessor = SceneSequenceEventQueueProcessor;
//# sourceMappingURL=SceneSequenceEventQueueProcessor.js.map