"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryFormatter = void 0;
const model_1 = require("@serenity-js/core/lib/model");
/**
 * @package
 */
class SummaryFormatter {
    constructor(theme) {
        this.theme = theme;
    }
    format(aggregatedCategories) {
        const categoryNames = this.sorted(Object.keys(aggregatedCategories.categories)), maxCategoryNameLength = Math.max(...(categoryNames.map(categoryName => categoryName.length))), maxCategoryNameLengthAllowed = Math.min(Math.max(maxCategoryNameLength, 10), 30);
        return [
            this.theme.heading('Execution Summary'),
            '',
            ...categoryNames.map(categoryName => {
                const displayName = (categoryName.length > maxCategoryNameLengthAllowed
                    ? categoryName.slice(0, maxCategoryNameLengthAllowed - 4) + `...:`
                    : `${categoryName}:`).padEnd(maxCategoryNameLengthAllowed + 1);
                return `${this.theme.heading(displayName)} ${this.formatTotalsFor(aggregatedCategories.categories[categoryName])}`;
            }),
            ``,
            `Total time: ${this.theme.heading(aggregatedCategories.totalTime)}`,
            `Real time: ${this.theme.heading(aggregatedCategories.realTime)}`,
            `Scenarios:  ${this.theme.heading(aggregatedCategories.numberOfScenarios)}`,
            '',
        ].join('\n');
    }
    sorted(strings) {
        return strings.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    }
    formatTotalsFor(category) {
        const outcomes = Object.keys(category.outcomes)
            .filter(outcomeName => category.outcomes[outcomeName].count > 0)
            .sort((left, right) => category.outcomes[left].code > category.outcomes[right].code ? 1 : -1)
            .reduce((acc, outcomeName) => {
            acc.push(this.theme.outcome(outcomeName, `${category.outcomes[outcomeName].count} ${this.nameOf(outcomeName)}`));
            return acc;
        }, [])
            .join(', ');
        const total = Object.keys(category.outcomes).map(outcomeName => category.outcomes[outcomeName].count).reduce((acc, count) => acc + count, 0);
        return `${outcomes}, ${total} total (${category.totalTime})`;
    }
    nameOf(outcomeName) {
        switch (outcomeName) {
            case model_1.ExecutionCompromised.name: return 'compromised';
            case model_1.ExecutionFailedWithError.name: return 'broken';
            case model_1.ExecutionFailedWithAssertionError.name: return 'failed';
            case model_1.ImplementationPending.name: return 'pending';
            case model_1.ExecutionSkipped.name: return 'skipped';
            case model_1.ExecutionIgnored.name: return 'ignored';
            // case ExecutionSuccessful.name:
            default:
                return 'successful';
        }
    }
}
exports.SummaryFormatter = SummaryFormatter;
//# sourceMappingURL=SummaryFormatter.js.map